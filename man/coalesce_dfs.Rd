% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/coalesce_dfs.R
\name{coalesce_dfs}
\alias{coalesce_dfs}
\title{Update shared columns between two data.frames.}
\usage{
coalesce_dfs(x, y, vars_to_update = "all", precedence = "x", by = NULL,
  ...)
}
\arguments{
\item{x}{the data.frame to update}

\item{y}{the data.frame from which to draw updates.  Must be join-able to \code{x}.  Columns to update must be identically named in the two data.frames.}

\item{vars_to_update}{either "all" (the default) to update all variables that share names, or a character vector of column names if not all identically-named vectors should be updated.}

\item{precedence}{if there are non-\code{NA} values for a vector in both data.frames, which value should be selected?}

\item{by}{a character vector of variables to join by.  Gets passed on to \code{dplyr::left_join}.}

\item{...}{other parameters passed on to \code{dplyr::left_join}.}
}
\value{
the coalesced version of the input data.frame \code{x}.
}
\description{
Update all the columns in a data.frame using identically-named columns in another.  Where the second data.frame has \code{NA} values, the original value will be retained.  This is a wrapper function for calling \code{dplyr::coalesce} on many columns at once; understand that function to understand this one.
}
\examples{
t1 <- data.frame(id = 1, lo = as.numeric(NA), med = 3, hi = as.numeric(NA), other = "still here")
t2 <- data.frame(id = 1, med = 4, hi = 10, lo = 1)
coalesce_dfs(t1, t2, by = "id")
coalesce_dfs(t1, t2, vars_to_update = c("lo"), by = "id") # update just the specified col
}

